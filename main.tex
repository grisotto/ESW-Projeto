\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc} % sempre salve seus arquivos como UTF8
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
%Paulo - adicona esta linha
\usepackage[backend=biber, doi=true, maxbibnames=9, maxcitenames=2]{biblatex}


\usepackage[left=2.5cm,right=2cm,top=2cm,bottom=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{color}
\usepackage[noend]{algpseudocode}
\usepackage{mathtools}
\usepackage{fancybox}
\usepackage{tikz}
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage{csquotes}
\usepackage{xcolor}  % Coloured text etc.
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
% load times font
\usepackage{mathptmx}
\usepackage[scaled=.90]{helvet}
\usepackage{courier}
%Qual linha?
\bibliography{general.bib}

% teoremas, lemas, etc...
\newtheorem{questao}{Questão}
\newtheorem{invariant}{Invariante}
\newtheorem{theorem}{Teorema}
\newtheorem{lemma}[theorem]{Lema}
\renewcommand*{\proofname}{Demonstração}

% comandos
\newcommand{\mdc}[1]{\mathrm{mdc}(#1)}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
% 
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=gray,backgroundcolor=gray!25,bordercolor=gray,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

\title{Otimização Combinatória em  \\ testes}
\author{Rafael Grisotto e Souza - RA 192765\\ Vinícius Loti de Lima - RA 209829 \\ Paulo Henrique Carvalho de Morais - RA 192877}



\begin{document}

\maketitle


\begin{questao}
\end{questao}

Resumo de Search-Based Software Testing.
https://ieeexplore.ieee.org/document/5954405/

Descrever EvoSuite (meta heurística)
http://www.evosuite.org/publications/

Terminar: Resumo SBST e dizer o que iremos fazer com base nos slides, perguntas de pesquisa, avaliar os métodos e etc. 


Olhar os artigos deles para fazer experimentos.

Terminar Evosuite

Adicionar outras metaheurista e limpar um pouco o texto.

Alternativas para melhorar os resultados: meta heurística a, b, c, ...


Trabalho 2 começa aqui:
\cite{arcuri2017restful}
Projetar e rodar experimento com todas ou um subconjunto e comparar.

\listoftodos[Notes]



\newpage

\section{Introdução}

As publicações em "Teste de Software Baseados em Busca" começaram em 1976 com [1]. Mas foi depois de vários anos, em 1990, que Korel [3], [4] deu continuidade a essa linha de pesquisa, e em 1992, [5] aplicou algoritmos genéticos em geração de casos de teste. 

Em geração de casos de testes por meio de algoritmos de busca, as entradas são geradas aleatóriamente até que os objetivos do teste seja satisfeito [0]. Uma busca aleatória pode não ser muito eficiente para geração de casos de teste, quando o espaço de busca é muito maior do que o espaço de soluções viáveis. O ideal é utilizar algoritmos mais guiados, assim como algumas meta-heurísticas, onde existe uma função chamada de função de fitness (\emph{fitness function}), que é dependente do problema sendo resolvido pela meta-heurística, que serve para guiar a busca por soluções, retornando valores que indicam a qualidade de cada solução encontrada. 

Alguns exemplos de aplicações de funções de fitness, presentes em [0]:

Testes temporais: busca aproximar os tempos de execução para o melhor e pior caso para componentes de um sistema. Uma forma de modelar esse problema como teste baseado em buscas, é definindo a função de fitness como sendo o tempo de execução do componente, para uma dada entrada. Para melhorar a qualidade dos atributos encontrados pela busca, pode ser utilizada análise estática.

Testes funcionais: busca testar a funcionalidade de componentes de um sistema. Um exemplo de teste funcional baseado em busca é dado em [6], [7], onde foi testado um sistema de estacionamento que identifica uma vaga de etacionamento e automaticamente manobra o carro para estacioná-lo na vaga sem causar colisões. A função de fitness usada foi então a distância mínima até um ponto de colisão, onde o objetivo era então minimizar essa distância, para detectar possíveis falhas no sistema.

Testes estruturais: foi a origem de testes baseados em busca, apresentada em [1], e é a área de aplicação que mais vem atraindo atenção em testes baseados em busca. Para testes de cobertura de branches, por exemplo, pode ser utilizada uma função de fitness dada pela normalização da distância de branch, até um dado nó da árvore do programa.



\section{Referencial EvoSuite}

\textit{EvoSuite} é uma ferramenta que automatiza a geração de suítes de testes com alta taxa de cobertura, pequenas o suficiente e fornece asserções. Ele gera as suítes de testes tantos para classes individuais quanto para projetos inteiros, sem requerer comandos complicados adicionais. Esta ferramenta é livre, e pode ser usada em linha de comando ou como  plugins para da plataformas de desenvolvimento como por exemplo o Eclipse\footnote{http://www.evosuite.org/downloads/} \cite{fraser2011evosuite}.

O \textit{EvoSuite} utiliza \textit{whole test suite generation} e \textit{Mutation-based assertion generation} para alcançar os seus objetivos eficientemente, os quais serão descritos a seguir serão descritos a seguir:

\subsection{Whole Test Suite Generation}

Uma abordagem comum na literatura é gerar um caso de teste para cada meta individuais de cobertura (ex, \textit{branches in branch coverage}), e então os combinam em uma única suíte de teste. Porém, o tamanho resultante da suíte de testes é difícil de predizer pois um caso de teste gerado para uma meta pode implicitamente também cobrir qualquer quantidade de metas de cobertura à frente. Ou seja, a ordem em que cada meta é escolhida pode desempenhar um papel importante, pois pode haver dependências entre elas. Há outros problemas quando se considera uma meta de cada vez, como metas quem podem ser mais difíceis de cobrir do que outras, ou até mesmo serem inviáveis \cite{fraser2013whole}.

Para superar esses problemas, \textit{whole test suite generation} é uma abordagem que não produz casos de testes para cada meta individual de cobertura, ao invés disso foca em suítes de testes visando um completo critério de cobertura. Otimizando em relação em critério de cobertura ao invés de metas individuais cobertura tem resultados que não são influenciados pela ordem, pela dificuldade nem pela inviabilidade dos casos de testes \cite{fraser2011evosuite}.

\textit{EvoSuite} implementa \textit{whole test suite generation} como um algoritmo genético, onde uma suíte de testes é considerada como uma solução candidata. Cada suíte de teste consiste de um número variável de casos de testes, que por sua vez, consiste em uma sequência de instruções. O crossover entre duas suítes de testes são trocados casos de testes entre si baseado em uma escolha aleatória da posição do crossover. A mutação de uma suíte de teste adiciona novos casos de testes, ou modifica testes individuais. Já a mutação de casos de testes são adicionados, removidos ou mudados instruções ou parâmetros.

O \textit{fitness} dos indivíduos é calculado com base a um critério de cobertura, no caso o \textit{EvoSuite} usa \textit{branch coverage} como critério de teste. Para que seja realizada a evolução são recompensados aqueles indivíduos o quais possuem uma melhor cobertura. Quanto maior o tamanho das suítes de testes maior a chance de cobrir as metas de cobertura, e o \textit{EvoSuite} permite que a busca aprofunde em sequencias longas, porém é aplicado várias técnicas de \textit{bloat control}. Essa técnicas de \textit{bloat control} assegura que indivíduos não fiquem excecivamente muito grandes, com isso, no fim da busca as suítes de testes são minimizadas tal que apenas instruções contribuindo para a cobertura permaneçam.

\subsection{Mutation-Based Assertion Generation}

Os casos de testes precisam de algum tipo de testes de oraculo manual para que assim o engenheiro de software verifique e capture a corretude da unidade sobre testes que não se pode detectar com oráculos automatizados. No caso de testes unitários esses oráculos manuais geralmente são asserções. Dado um teste de unidade gerado automaticamente, existe um número finito de código que pode ser gerado uma asserção. Porém mesmo que seja limitado, mostrar todas as asserções para o desenvolvedor pode ser problemático, pois para uma falha seja detectada o desenvolvedor precisa verificar a corretude das asserções, e muitas delas podem ser irrelevantes. Semelhante a isso, um caso de teste pode falhar em um ponto posterior, indicando falha de regressão, quando de fato ele possui muitas asserções e isso causa várias restrições, assim conduzindo a falsos alarmes \cite{fraser2011evosuite}.

Para determinar a importância e efetividade das asserções, o \textit{EvoSuite} aplica testes de mutação. Em testes de mutação, defeitos (mutantes) são semeados no programa testados nas suítes de testes. Quanto mais defeitos detectados com o menor número de asserções melhor a qualidade do caso de teste, entretanto, se os defeitos não forem encontrados significa que o caso de teste precisa de melhoras. Após a geração dos casos de testes, o \textit{EvoSuite} roda cada caso de teste no programa sem modificações assim como nos mutantes criados, assim analisando quais defeitos são encontrados pelas asserções. Após isto o \textit{EvoSuite} seleciona as asserções suficientes para encontrar a maior quantidade de defeitos no programa em análise.

\subsection{Resultados do \textit{EvoSuite}}

\citeauthor{fraser20151600} testaram 100 projetos de código aberto selecionados randomicamente no \textit{EvoSuite} a fim de avaliarem a escalabilidade quando existem vários testes. Neste trabalho é mostrado que o \textit{EvoSuite} é capaz de exercitar oráculos automatizados e produzir alta cobertura de testes ao mesmo tempo. Nos experimentos foram encontrados 32594 falhas distintas em 8844 classes, o que pode pode ser considerado pelo menos 1694 como falhas reais \cite{fraser20151600}.


\newpage

\section{Meta-Heurísticas} 

Meta-heurística é um subcampo primário da otimização estocástica, a qual consiste de algoritmos e técnicas que empregam algum grau de aleatoriedade para encontrar a solução ótima (ou a
melhor possível) para problemas reconhecidamente difíceis. \citeauthor{luke2009essentials} \cite{luke2009essentials} ressalva que meta-heurística é um termo que pode gerar desentendimentos
uma vez que não se trata de heuristica sobre (ou para) heurísticas, o que não é necessariamente verdade para todos os algoritmos.  


\info{Precisa falar das metaheuristicas, quais iremos usar, algum por que de cada uma e depois dizer como elas estão organizadas na seção}

\subsection{Colonia de formigas}

Uma metaheurista bio-inspirada que pode ser útil para o nosso projeto é Colônia de Formigas \cite{dorigo1999ant} ( do inglês \textit{Ant Colony Optimization} ) que surgiu da observação do
comportamento das formigas reais e incluso técnicas de busca local posteriormente. 

\subsection{Colonia de abelhas}

\subsection{Enxame de partículas}

\subsection{Algoritmo Genético}
\label{sec:alg_genetic}



Um algoritmo genético simula a seleção natural, onde cada indivíduo compete com os outros para sobreviver com base em sua aptidão (\emph{fitness}). Os indivíduos que sobrevivem ao passo de
seleção passam por operações genéticas (cruzamentos e mutações), simulando o que ocorre na biologia, para assim criar uma nova população.

    \subsection{Método de seleção de indivíduos}

        Torneio funciona que até que se tenha cromossomos suficientes para fazer a recombinação, nesse caso 4, dois cromossomos são escolhidos aleatoriamente da população, usando uma distribuição de
        probabilidade uniforme, e o de melhor \textit{fitness} é selecionado para o processo de recombinação.

    \subsection{Método de \textit{crossover}}

        Operador de \textit{crossover} $C1$ são dados dois pais, $p_1$ e $p_2$, é escolhido um ponto de corte até o qual o filho será igual ao $p_1$. Então, os elementos que faltarem no
        cromossomo filho (todos os clientes faltantes até o ponto de corte) são inseridos no filho seguindo a ordem em que aparecem em $p_2$. 

        Operador de \textit{crossover} do tipo \emph{crossover OX}, por se tratar de um cruzamento para codificação de permutação que, além de ser simples, exige um baixo custo computacional
        quando comparado com os outros esquemas de recombinação para a representação de permutação, desta maneira um maior número de recombinações são possíveis para um tempo fixo de processamento
        da simulação. 

        Outro método de \textit{crossover} de dois indivíduos $A$ e $B$ é usando \textit{crossover} de dois pontos, que é feito selecionando-se aleatoriamente $2$ locus nas posições $L$ e $R$,
        com $L < R$, para serem os pontos da troca.  O primeiro indivíduo é gerado a partir da fusão entre as posições $[0, L]$ e $]R, size(A) - 1]$ de $A$ e as posições $]L, R]$ de $B$, já
        o segundo indivíduo é gerado a partir das posições $[0, L]$ e $]R, size(B) - 1]$ de $B$ e as posições $]L, R]$ de $A$.

        Por fim, o \textit{Uniform Crossover} em vez de escolher aleatoriamente dois pontos de cruzamento, a cada locus, um pai é escolhido aleatoriamente para ter seu alelo copiado; o alelo
        deste pai é copiado para o primeiro descendente enquanto o alelo do outro pai do mesmo locus é copiado para o segundo descendente.

        Da mesma maneira que no método de \textit{crossover} de dois pontos, após a criação da nova geração através desta recombinação, todos os descendentes são verificados e, para todo par de locus
        consecutivos com alelos iguais a 1, um destes locus é escolhido aleatoriamente e seu alelo alterado para 0.

        Após o \textit{crossover}, é necessário fazer a correção de possíveis indivíduos inválidos segundo as restrições do problema.

    \subsubsection{Método de mutação}

         Para uma população, são visitados todos os cromossomos e cada um será mutado se for escolhido um número aleatório maior que a taxa de mutação utilizada. Existe um valor $1/m$
         \cite{gendreau2010handbook} que diz ser um valor ideal para mutações, onde $m$ é o tamanho da instância de entrada.
         
        Após a mutação, também é necessário fazer correções, pois pode haver indivíduos inválidos devido às restrições do problema.


    \subsection{\emph{Steady-state}}

        Tipicamente, a execução de um algoritmo genético é dividido em gerações que são substituídas (quase que por completo) a cada iteração do algoritmo. No caso do algoritmo genético
        \emph{steady state} apenas alguns indivíduos são substituídos ao final de cada iteração.

        Neste processo, dois pais devem ser selecionados da população atual e um filho deve ser gerado pelo processo de \emph{crossover}. Em seguida, o pior indivíduo dentre ambos os pais e filho é
        removido e os outros dois são realocados (se necessário) na população. Com isso, o conceito de gerações passa a não fazer sentido pois, neste caso, tem-se apenas um filho gerado enquanto o
        resto da população permanece constante.  

    \subsubsection{Manutenção de diversidade}

        Para manter os indivíduos diversos e evitar a convergência muito cedo, pode ser usado uma função que diversifica a população após a seleção de pais, criação e mutação da geração atual.

        Neste caso, realizam-se testes 2 a 2 em cada indivíduo e se os indivíduos possuírem um número maior que o valor pré-definido (0.5$\%$, por exemplo ) de alelos iguais, o primeiro dos
        dois sofre uma mutação aleatória em um locus.


\subsection{BRKGA}
\label{sec:alg_genetic}

    O BRKGA (biased random-key genetic algorithm)\cite{gonccalves2011biased} é uma metaheuristica para encontrar uma solução ótima ou próxima da ótima. É uma variação do RKGA
    (random-key genetic algorithms) \cite{bean1994genetic} e se obtém uma solução viável para o problema através da decodificação de uma solução codificada. A solução codificada são vetores de
    chaves aleatórias em um intervalo de números reais continuo $(0,1]$ e a decodificação é uma etapa que mapeia um vetor de chaves aleatórias numa solução do problema de otimização e calcula o
    seu custo. Note que o BRKGA tem como seu algoritmo sendo independente do problema. 

    De forma resumida, a definição de algumas características do BRKGA: 


        \begin{itemize}

        \item Codificação de uma solução com chaves aleatórias em intervalo continuo $[0,1]$ 

        \item Geração de população inicial com $p$ vetores de $n$ chaves aleatórias

        \item Método de seleção de indivíduos é ordenado pelo $fitness$ e gerado dois grupos, elite e não-elite. Após, é escolhido um pai do conjunto elite e o outro é escolhido do conjunto
            não-elite. Com estes é gerado a próxima geração. 

        \end{itemize}

        Todas as variações descritas no algoritmo genético \ref{sec:alg_genetic} são possíveis de se aplicadas no BRKGA. 

%\subsection{GRASP}
%\label{sec:grasp}

    %O GRASP (Greedy Randomized Adaptive Search Procedure) para problemas de otimização combinatória foi introduzida por Feo e Resende \cite{feo1989probabilistic}. O GRASP tem sua iteração
    %primeiramente a construção de uma solução inicial a partir de uma heurística construtiva gulosa e aleatória. Depois, é realizado uma busca local com intenção de explorar a vizinhança da
    %solução inicial até atingir um mínimo local do espaço de soluções. Após um critério de parada como quantidade de iterações ou tempo de processamento o GRASP devolve a melhor solução
    %encontrada e termina sua execução.



    %\subsubsection{Busca Local}

        %Método de Busca Local: regula o tipo de busca realizada na fase de busca local. Aceita valores '\textit{best improving}' ou '\textit{first improving'}. O primeiro busca por toda a vizinhança
        %a procura da melhor solução local do valor objetivo possível, enquanto o segundo procura apenas pela primeira melhoria no valor objetivo;





\subsection{Busca Tabu}
\label{sec:busca_tabu}

    A Busca Tabu é uma busca local que permite movimentos que podem não melhorar a solução atual. Para evitar ciclos, existe um mecanismo chamado lista tabu onde os últimos movimentos realizados
    ficam armazenados por um dado número de iterações, chamado \textit{tenure}. Os movimentos que estão na lista de tabus ficam proibidos, a menos que um dado critério de aspiração seja
    satisfeito. Caso um critério de aspiração seja satisfeito o movimento é permitido. A heurística foi originalmente proposta por \citeauthor{glover1986future} \cite{glover1986future} e nos
    últimos 20 anos centenas de artigos utilizam Busca Tabu em diversos problemas de combinatória e mostrando ser bastante eficaz com resultados bem próximos do ótimo ou conseguindo o ótimo
    \cite{gendreau2010handbook}.

    Na Busca Tabu precisamos definir muito bem o espaço de busca e a estrutura da vizinhança. Definir os critérios da restrição de movimentos. Pode ser complicado deixar a metaheuristica
    suficientemente genética para ser usada no framework EvoSuite, porém podemos pensar em casos não muito gerais e aplicar mecanismos de busca por intensificação e por diversidade.


    \subsubsection{Intensificação}

        Uma possível intensificação por vizinhança é que no qual são explorados todos os movimentos possíveis (inserção, remoção e troca) com quaisquer três elementos. 

    \subsubsection{Método de Busca Local}

        \begin{itemize}

        \item {\it Best Improving:} onde toda a exploração da vizinhança de uma solução é dada até a exaustão, ou seja, todos os elementos são analisados até que o mínimo local seja encontrado. Como
            a busca está restrita a vizinhança da solução o mínimo encontrado é local, e não se tem garantida quanto a otimalidade global. No mesmo intuito de buscar por soluções sempre factíveis, a
                fim de não aplicar operadores de reparo nas soluções, a técnica de {\it best improving} só analisa a vizinhança factível. 

        \item {\it First Improving:} a busca na vizinhança é feita usando as técnicas de inserção, remoção e troca. Todas as opções factíveis para as três técnicas são colocadas em uma lista
        e um dos elementos dessa lista é selecionado de forma aleatória, assim que a primeira melhora é encontrada o processo de busca nessa vizinhança para e a lista é atualizada para
        contemplar as novas opções factíveis. 
        \end{itemize}

    \subsubsection{\it Surrogate Objective} 

        Ao resolver um problema por meta-heurísticas, ou ainda, heurísticas, é imprescindível a escolha de uma boa função de avaliação da solução. Por vezes, a melhor escolha para a função de
        avaliação não é a função objetivo, seja porque o calculo da função objetivo tem alto custo computacional ou ainda porque ela não trás informações precisas sobre a solução que está sendo
        tratada. Nesses casos é interessante o uso de uma função de avaliação diferente, conhecida também como {\it surrogate objective}.



    \subsubsection{Diversificação por Reinício}

        Envolve forçar alguns componentes que são raramente utilizados na solução e reiniciar o processo de busca a partir deste ponto.  Seja $t$ o \textit{tenure}, quando a busca é
        reiniciada são colocados os $t$ movimentos mais frequentes no tabu, colocando primeiro o menos frequente e por o último o mais frequente. A frequência é calculada somando 1 cada vez
        que o movimento é realizado pelo operador de busca local. A frequência não é reiniciada quando a busca recomeça. Quando a busca reinicia uma nova solução inicial é construída.


\section{Metodologia}


\printbibliography
\end{document}


